<!DOCTYPE html>
<html lang="ko">
<head>
    <title>Monkey</title>
    <meta charset="utf-8"/>
    <meta property="og:image" content="http://shallaa.github.io/SoftEngine/og/1.jpg"/>
    <meta property="og:title" content="Monkey"/>
    <meta property="og:description" content="MoGL.js version"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="format-detection" content="telephone=no"/>
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black"/>
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no,target-densitydpi=high-dpi "/>
    <style>
        body {
            background-color: #000;
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
        }

        .FPS {
            color: #FFF;
            left: 0px;
            top: 0px;
            position: absolute
        }
    </style>
    <script src="../src/MoGL.js"></script>
    <script src="../src/BlendMode.js"></script>
    <script src="../src/Filter.js"></script>
    <script src="../src/Vertex.js"></script>
    <script src="../src/Shading.js"></script>
    <script src="../src/VertexShaderFunctions.js"></script>
    <script src="../src/Matrix.js"></script>
    <script src="../src/Geometry.js"></script>
    <script src="../src/Material.js"></script>
    <script src="../src/Texture.js"></script>
    <script src="../src/Mesh.js"></script>
    <script src="../src/Group.js"></script>
    <script src="../src/Camera.js"></script>
    <script src="../src/Scene.js"></script>
    <script src="../src/World.js"></script>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
    /////////////////////////////////////////////////////////////////
    /*
     목표는
     1. 메쉬단위별로 전부 파싱하고... - 완료
     2. v/vt형 파싱 - 완료
     2. v/vt/vn형 파싱 - 완료
     2. 재질 특성 즉 mtl값을 반영하게 하고..
     3. 따라서 암비안트, 디퓨즈, 스페큘라 값도 읽어온다.
     3. 그룹이 완성되면 그룹으로도 파싱하도록.
     */
    /////////////////////////////////////////////////////////////////
    'use strict';
    var world = new World('canvas');
    var scene = new Scene();
    world.addScene(scene);
    scene.addChild('camera', new Camera());
    scene.addMaterial('material1', new Material(1, 1, 1, 1));
    scene.addMaterial('material2', new Material(1, 1, 1, 1));
    scene.addTexture('texture1', 'test/test.png');
    scene.addTexture('texture2', 'woman/woman.png');
    scene.getMaterial('material1').addTexture(Texture.diffuse, 'texture1').setShading(Shading.phong);
    scene.getMaterial('material2').addTexture(Texture.diffuse, 'texture2').setShading(Shading.phong);

    world.start()
    world.setAutoSize(1)

    var xmlhttp = new XMLHttpRequest();
    xmlhttp.open('GET', 'test/test.obj', true);
    xmlhttp.onreadystatechange = function () {
        if (xmlhttp.readyState === 4 && xmlhttp.status === 200) {
            start(xmlhttp.responseText);
        }
    };
    xmlhttp.send(null);
    function start(data) {
        var pardedData1 = parseObj(data)
        var result = {}
        for (var k in pardedData1) {
            var geo = new Geometry(pardedData1[k].vertex, pardedData1[k].index, [Vertex.x, Vertex.y, Vertex.z, Vertex.u, Vertex.v])
            scene.addGeometry(k, geo);

            var mesh = new Mesh(k, 'material1')
            scene.addChild(k, mesh)
            scene.getChild('camera').z = 150
            scene.getChild('camera').lookAt(mesh.x, mesh.y, mesh.z);
            result[k] = mesh
            mesh.x -= 50
            console.log('생성했다!', mesh)
        }
        world.addEventListener(World.renderBefore, function () {
            for (var k in result) {

                result[k].rotateY += 0.01
            }
        })
    }
    var xmlhttp2 = new XMLHttpRequest();
    xmlhttp2.open('GET', 'woman/woman.obj', true);
    xmlhttp2.onreadystatechange = function () {
        if (xmlhttp2.readyState === 4 && xmlhttp2.status === 200) {
            start2(xmlhttp2.responseText);
        }
    };
    xmlhttp2.send(null);
    function start2(data) {
        var pardedData1 = parseObj(data)
        var result = {}
        for (var k in pardedData1) {
            var geo = new Geometry(pardedData1[k].vertex, pardedData1[k].index, [Vertex.x, Vertex.y, Vertex.z, Vertex.u, Vertex.v])
            scene.addGeometry(k, geo);

            var mesh = new Mesh(k, 'material2')
            scene.addChild(k, mesh)
            scene.getChild('camera').z = 150
            scene.getChild('camera').lookAt(mesh.x, mesh.y, mesh.z);
            result[k] = mesh
            console.log('생성했다!', mesh)

            mesh.x += 50
        }
        world.addEventListener(World.renderBefore, function () {
            for (var k in result) {

                result[k].rotateY += 0.01
            }
        })
    }

    var parseObj = function parseObj(data) {
        var data = data.split('\n')
        var table = {}, temp, currentMesh, id
        for (var i = 0, len = data.length; i < len; i++) {
            temp = data[i]
            id = temp.substr(0, 2)
            if (temp.charAt(0) == 'o') {
                currentMesh = table[temp.substr(2).trim()] = {
                    vertex: [], uv: [], normal: [], vFace: [], uvFace: [], nFace: []
                }
            } else if (id == 'v ') {
                var a = temp.substr(2).split(' ');
                currentMesh['vertex'].push(a[0], a[1], a[2])
            } else if (id == 'f ') {
                var a = temp.substr(2).replace(/ /g, '/')
                a = a.split('/');
                if (a.length == 6) {
                    currentMesh['vFace'].push(a[0] - 1, a[2] - 1, a[4] - 1)
                    currentMesh['uvFace'].push(a[1] - 1, a[3] - 1, a[5] - 1)
                } else if (a.length == 9) {
                    currentMesh.vFace.push(a[0] - 1, a[3] - 1, a[6] - 1)
                    currentMesh.uvFace.push(a[1] - 1, a[4] - 1, a[7] - 1)
                    currentMesh.nFace.push(a[2] - 1, a[5] - 1, a[8] - 1)
                }
//                console.log(a)


            } else if (id == 'vn') {
                var a = temp.substr(3).split(' ');
                currentMesh.normal.push(a[0], a[1], a[2])
            } else if (id == 'vt') {
                var a = temp.substr(3).split(' ');
                currentMesh['uv'].push(a[0], a[1])
            }

        }
        var realData = {}
        var more = 0
        for (var k in table) {
            realData[k] = {
                vertex: [], index: []
            }
            more += 1
            var vFace = table[k].vFace, uvFace = table[k].uvFace, nFace = table[k].nFace
            var tFace, tUVFace, tNFace, tGap, tResultVertex, tVertex, tUV, tNormal

            tVertex = table[k].vertex
            tUV = table[k].uv
            tNormal = table[k].normal

            for (var i = 0, len = vFace.length; i < len; i++) {
                if (more == 1) {
                    tFace = vFace[i]
                    tUVFace = uvFace[i]
                    tNFace = nFace[i]
                } else {
                    tFace = vFace[i] - vFace[0]
                    tUVFace = uvFace[i] - uvFace[0]
                    tNFace = nFace[i] - nFace[0]
                }


                tGap = tFace * 5
                tResultVertex = realData[k].vertex
                tResultVertex[tGap + 0] = tVertex[tFace * 3]
                tResultVertex[tGap + 1] = tVertex[tFace * 3 + 1]
                tResultVertex[tGap + 2] = tVertex[tFace * 3 + 2]

                tResultVertex[tGap + 3] = tUV[tUVFace * 2]
                tResultVertex[tGap + 4] = 1 - tUV[tUVFace * 2 + 1]

                realData[k].index.push(tFace)
            }
        }
        return realData
    }
</script>
</body>
</html>